/** @constructor */var ProjectData = function() {    this.projectItems = {        comps: [],        footage: [],        solids: [],        folders: []    }    this.folderObjects = [];};/** * ProjectData.prototype.run - the 'helper function' which sequentiallty runs the methods of * this object. * * @return {undefined}  None */ProjectData.prototype.run = function() {    app.beginUndoGroup("dc_mergeProjectFolders.jsx");    this.filterProject();    this.makeFolderObjects();    this.sortFolderObjects();    this.mergeFolders();    this.clearEmptyFolders();    app.endUndoGroup();};/** * ProjectData.prototype.filterProject - filters the project, categorixing items as either * solids, footage, comps or folders. * * @return {undefined}  none. */ProjectData.prototype.filterProject = function() {    /*    This function sorts the project items into their respective types.    */    for (var i = 1; i <= app.project.numItems; i++) {        var itm = app.project.item(i);        if (itm instanceof CompItem) {            this.projectItems.comps.push(itm); // item is a comp.        } else if (itm instanceof FolderItem) {            this.projectItems.folders.push(itm); // item is a folder.        } else {            if (itm.mainSource instanceof SolidSource) {                this.projectItems.solids.push(itm); // item is a solid.            } else {                this.projectItems.footage.push(itm); // item is footage.            }        }    }};/** * ProjectData.prototype.getDepth - gets the depth (number of parent project folders) * for any given project item. * * @param  {ProjectItem}  itm the item to find the depth of. * @return {undefined}    none */ProjectData.prototype.getDepth = function(itm) {    var dpth = 0;    var calcDepth = function(myItm) {        if (myItm.parentFolder.name !== "Root") {            dpth++;            calcDepth(myItm.parentFolder);        }    }    calcDepth(itm);    return dpth;};/** * ProjectData.prototype.makeFolderObjects - Turns project folders into FolderObjects. * * @return {undefined}  none. */ProjectData.prototype.makeFolderObjects = function() {    for (var i = 0; i < this.projectItems.folders.length; i++) {        var fldr = this.projectItems.folders[i];        this.folderObjects.push(new ProjectFolder(fldr, this.getDepth(fldr)));    }};/** * ProjectData.prototype.sortFolderObjects - Sorts folder objects inside of this.folderObjects * using a custom sorting function (depth of folder.) * * @return {undefined}  none. */ProjectData.prototype.sortFolderObjects = function() {    var folderHolder = this.folderObjects.slice(0);    /**     * var newOrder - takes the Array folderHolder and sorts it based on     * its folders' depths.     *     * @param  {FolderObject} a     current object     * @param  {FolderObject} b     object to compare against.     * @return {}             none.     */    var newOrder = folderHolder.sort(function(a, b) {        if (a.depth < b.depth) {            return -1;        }        if (a.depth > b.depth) {            return 1;        }        return 0;    });    this.projectItems.folders = newOrder;};/** * ProjectData.prototype.mergeFolders - the main logic of the script. When called, compares * the folders inside of this.folderObjects and merges the contents to the least-nested. * * @return {undefined}  none. */ProjectData.prototype.mergeFolders = function() {    var folderHolder = this.folderObjects.slice(0);    /**     * var copyContents - Copies contents from one folder to another.     *     * @param  {FolderItem} s Source folder Object     * @param  {FolderItem} d Destination folder object.     * @return {undefined}   none.     */    var copyContents = function(s, d, ts, td) {        if (s == d) {            return true;        }        if (d instanceof FolderItem) {            if (s instanceof FolderItem) {                // items start at 1 in AE.                for (var i = s.numItems; i >= 1; i--) {                    try{                      s.item(i).parentFolder = d;                    } catch(e){                      // log this error and find a way to fix it.                      continue;                    }                }                return true;            } else if (s instanceof FootageItem) {                d.parentFolder = s;                return true;            } else {                return true;            }        } else {            return false;        }    };    // i = most nested folder working backwards.    // j = least nested folder working forewards.    for (var i = folderHolder.length - 1; i >= 0; i--) {        for (var j = 0; j < i; j++) { // only check up to index i (since we're going backwards in the i loop and fwds in j loop).            if (folderHolder[j].name == folderHolder[i].name) {              copyContents(folderHolder[i].folder, folderHolder[j].folder, folderHolder[i], folderHolder[j]);              break;            }        }    }};/** * ProjectData.prototype.clearEmptyFolders - Cleans empty folders from an AEP. * * @return {undefined}  none. */ProjectData.prototype.clearEmptyFolders = function() {    var fldrs = this.projectItems.folders;    for (var i = fldrs.length - 1; i >= 0; i--) {        if (fldrs[i].folder.numItems == 0) {            fldrs[i].folder.remove();        }    }};